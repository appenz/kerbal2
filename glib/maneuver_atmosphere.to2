//
// Atmospheric Maneuvers
//

use { Vessel, VesselSituation, AutopilotMode, DeltaVSituation, ParachuteSafeStates, FlightCtrlState } from ksp::vessel
use { GeoCoordinates, find_body } from ksp::orbit
use { sleep, current_time, wait_until, yield } from ksp::game
use { warp_to } from ksp::game::warp
use { CONSOLE, RED, GREEN, BLUE, YELLOW } from ksp::console
use { vec2, vec3, Vec3 } from ksp::math
use { DEBUG } from ksp::debug

use { acos_deg, clamp, sqrt, PI, min, max, abs } from core::math
use { format } from core::str

use { warning, panic, pretty_time, pretty_trend, pretty_distance } from glib::display
use { Node, ErrorNode, circularize_at_ap, circularize_at_pe, change_pe_at_ap, change_ap_at_pe } from glib::maneuver_vacuum
use { Mission } from glib::mission
use { Universe, Locations, lon_sunny_side, lat_nice_spot, check_and_finish_ssb, has_ssb } from glib::utility

// Burn a maneuver node that is part of an atmospheric ascent
// This means:
// - We don't trust the built-in nodes
// - Set AP to holding horizontal, don't follow maneuver
// - Check we don't exceep max AP

pub fn burnNextNodeAtm(mission: Mission, ap_target: float) -> Unit = {
    let con  = mission.console.value
    let vessel = mission.vessel
    let orbit = vessel.orbit
    const node_result = vessel.maneuver.next_node()

    if (!node_result.success) {
        warning("called burn_node with no maneuver node set.")
        return
    }

    if (mission.stage_thrust == 0) {
        panic("calling burnNextNode with zero thrust!")
        return
    }

    if (!vessel.orbit.apoapsis.defined) {
        panic("orbit has no apoapsis defined.")
        return
    }

    const node = node_result.value
    const target_orbit = node.expected_orbit
    const frame = vessel.main_body.celestial_frame

    // Need code here to orient vessel first
    warp_to(node.time - 10)
    vessel.autopilot.enabled = true
    vessel.autopilot.mode = AutopilotMode.Maneuver
    wait_until(fn() -> node.ETA <= 0.2)

    // Maneuver nodes seem a bit broken right now. Lock direction.
    vessel.autopilot.mode = AutopilotMode.StabilityAssist

    let dv_min = 10E35
    let dv_total = node.global_burn_vector.vector
    let dv = dv_total
    let burn_time = node.burn_duration
    let stop = false

    con.log(format("Atmospheric burn dv: {0:N0} m/s  dt: {1}  ap_max: {2} m", (dv.magnitude, pretty_time(burn_time), ap_target)))
    const  t_start = current_time()

    while (dv.magnitude > 0.1 && !stop) {
        const t = current_time()
        const ap = vessel.orbit.apoapsis.value

        // Limit throttle based on dv remaining
        dv = target_orbit.global_velocity(t).to_relative(frame) - vessel.orbit.global_velocity(t).to_relative(frame)
        burn_time = dv.magnitude/(mission.stage_thrust/vessel.mass)
        let throttle = clamp(burn_time/2, 0.01,1.0)

        // Limit throttle if close to AP
        const t_ap = vessel.orbit.next_apoapsis_time().value
        const v_ap = target_orbit.global_velocity(t_ap).to_relative(frame).magnitude
        const v_ap_target = vessel.orbit.global_velocity(t_ap).to_relative(frame).magnitude


        if( mission.flameout() ) {
            con.log("  flameout.")
            vessel.set_throttle(0)
            mission.stage()  
        }

        if (ap > ap_target) {
            con.log("  stop burn due apoapsis exceeding target "+ap_target.to_string())
            stop = true
        }

        if (dv.magnitude > dv_min*1.1) {
            con.log("  stop burn due to dv increasing at "+dv.magnitude.to_string())
            stop = true 
        }
        dv_min = min(dv.magnitude,dv_min)

        con.h4 = format("Node Burn: {0:N1} s ({1:P1})   dV: {2:N2} ({3:P1})  throttle: {4}", 
                        (burn_time,burn_time/node.burn_duration, dv.magnitude, dv.magnitude/dv_total.magnitude, throttle) )
        con.h5 = format("AP Target Mode: {0:N0} vs {1:N0} ({2:P1})   v_ap: {3:N0} vs {4:N0}", 
                        (ap, ap_target, abs(ap_target-ap)/ap_target, v_ap, v_ap_target ))

        if (!stop) {
            vessel.set_throttle(throttle)
            sleep(0.2)
            con.update_slow()
        }
    }

    vessel.set_throttle(0)
    yield()
    con.log(format("  ended after {0}", (pretty_time(current_time()-t_start))))
    sleep(1)
    vessel.autopilot.mode = AutopilotMode.Prograde
    node.remove()
}

//
// Launch the vessel from a planet with an atmosphere into orbit using a gravity turn
//
pub fn gravity_turn(mission: Mission, target_apoapsis: float, 
                          turn_start: float, turn_pitch: float, heading: float) -> Unit = {

    const vessel = mission.vessel
    const con = mission.console.value
    const startDV = mission.getTotalDV()

    // If we are landed or pre-launch, launch
    if (vessel.situation == VesselSituation.Landed || vessel.situation == VesselSituation.PreLaunch) {4
        con.log("Vessel is on the ground. Launch.")
        vessel.set_throttle(1)
        sleep(0.2)
        vessel.autopilot.mode = AutopilotMode.StabilityAssist
        vessel.staging.next()
        sleep(0.3)

        // find launch clamps and check if they are still latched
        for (part in vessel.parts)
        {
            if (part.is_launch_clamp)
            {
                con.log("Found a launch clamp")
                if (part.launch_clamp.defined)
                {
                    con.log("Releasing launch clamps!")
                    let lac = part.launch_clamp.value
                    if (!lac.is_released)
                        lac.release()
                }
            }
        }
    }

    // calculate gravity turn altitudes
    const atm_depth = vessel.main_body.atmosphere_depth
    con.log(format("Target Apoapsis {0:N0}km, heading {1:N0} deg.", (target_apoapsis/1000.0, heading)))
    con.h3 = format("Gravity turn will start at {0:N1} m/s", turn_start)

    let spd = 0.0
    let alt = vessel.altitude_terrain
    let t_apo = 0.0
    // Phase one: burn until turn start speed in m/s
    while(vessel.surface_velocity.magnitude < turn_start-5) {
        spd = vessel.vertical_surface_speed
        con.h4 = format("  speed: {0,6:N1}m/s, alt: {0,6:N1}", (spd, vessel.altitude_terrain))
        con.update()
        t_apo = vessel.orbit.next_apoapsis_time().value - current_time()
        sleep(0.1)
    }
    vessel.override_input_roll(0)

    //
    // start pitching maneuver
    //
    con.h3 = format("Pitching over to {0:N1}Â°...",(turn_pitch))
    con.update()
    ksp::game::warp::cancel()
    vessel.autopilot.mode = AutopilotMode.Autopilot

    // pitch over
    const target_pitch = turn_pitch
    for (pitch in 0..(target_pitch*5).to_int-1) {
        sleep(0.15)
        con.update()
        vessel.autopilot.target_orientation = vessel.heading_direction(heading, 90.0-pitch/5, 0).vector
    }
    sleep(2)
    vessel.autopilot.target_orientation = vessel.heading_direction(heading, 90-target_pitch, 0).vector
    sleep(4)

    spd = vessel.surface_velocity.magnitude 
    t_apo = vessel.orbit.next_apoapsis_time().value - current_time()

    //
    // start gravity turn
    //
    con.h3 = "Gravity turn..."
    ksp::game::warp::cancel()
    vessel.autopilot.mode = AutopilotMode.Prograde

    let th = 100.0
    let targetApTime = 50.0
    let accApt = 0.0
    let lastApt = t_apo
    let hasSsb = has_ssb(mission)

    // Phase two: burn until trajectory reaches apoapsis
    while(vessel.orbit.apoapsis.value < target_apoapsis) {
        spd = vessel.surface_velocity.magnitude 
        t_apo = vessel.orbit.next_apoapsis_time().value - current_time()

        accApt = t_apo - lastApt
        lastApt = t_apo

        // TODO: should probably use a PID controller for this
        let apTimeDiff = t_apo - targetApTime
        let throttleDiff = abs(apTimeDiff/accApt)/1.7
        if (abs(accApt) > 0.05)
        {
            if (throttleDiff > 5)
                throttleDiff = 5.0
        }
        else
        {
            if (throttleDiff > 1)
                throttleDiff = 1.0
        }

        // make sure we don't over- or undershoot!
        if (t_apo >= targetApTime && accApt > 0)
            th -= throttleDiff
        if (t_apo <= targetApTime && accApt < 0)
            th += throttleDiff

        if (th >= 100) 
            th = 100 
        else
            con.h3 = "Throttling down to keep apoapsis..."

        if (th <= 30) 
        {
            th = 30
            if (hasSsb)
            {
                targetApTime = lastApt
            }
        }

        let dv = vessel.delta_v.stage(vessel.staging.current)
        let burnTime = dv.value.burn_time

        // cancel warp before staging
        if (burnTime < 5.0 && !has_ssb(mission) && ksp::game::warp::current_rate() > 1)
        {
            ksp::game::warp::cancel()
        }
        // increase throttle before staging
        if (burnTime < 3.0 && !has_ssb(mission))
        {
            th *= 2
        }

        // set throttle according to calculations
        vessel.set_throttle(th/100.0)

        // Check if we need to stage. 
        // Sometimes stage command is not executed, 
        // also check if there is any ignited engine and repeat if not
        if( mission.flameout_any() || !mission.ignited_any()) {

            if (mission.flameout()) // all flamed out?
                th = 50

            vessel.set_throttle(.05)
            con.log("Flameout, advancing to new stage.")
            mission.stage() 
            vessel.set_throttle(th/100.0)
        }

        con.h4 = format("  apoapsis in:         {0,6:N1}s", (t_apo))
        con.h5 = format("  stage burn remaining:{0,6:N1}s", (burnTime))

        con.update_slow()
        sleep(0.1/ksp::game::warp::current_rate())
    }

    ksp::game::warp::cancel()
    vessel.set_throttle(0)
    vessel.autopilot.mode = AutopilotMode.Prograde
    sleep(0.1)

    // If a solid state booster is still burning, wait for it to finish and stage
    check_and_finish_ssb(mission)

    t_apo = vessel.orbit.next_apoapsis_time().value
    con.h5 = format("Apoapsis {0:N0}km in {1:N0} seconds.", (vessel.orbit.apoapsis.value/1000, t_apo))

    //
    // start gravity turn
    //
    con.h3 = "Coasting..."
    con.update()
    sleep(1)
    // use time warp out of atmosphere during coasting
    warp_to(t_apo)

    while(vessel.altitude_sealevel < vessel.main_body.atmosphere_depth) {
        // boost if needed
        if (vessel.orbit.apoapsis.value < target_apoapsis)
        {
            for(i in 1..7 )
            {
                vessel.set_throttle(i/100.0)
                sleep(0.04)
            }
            for(i in 5..1 )
            {
                vessel.set_throttle(i/100.0)
                sleep(0.04)
            }
            vessel.set_throttle(0)
        }
        con.update()
        sleep(0.5)
    }
    sleep(0.5)
    ksp::game::warp::cancel()
    sleep(0.5)

    // Circularize at apoapsis
    let n1 = circularize_at_ap(vessel)
    mission.addManeuver(n1)
    // align with maneuver
    vessel.autopilot.mode = AutopilotMode.Maneuver
    sleep(1) // give it some time

    // execute
    mission.burnNextNode()

    const endDV = mission.getTotalDV()
    con.log("circularization burn complete.")
    con.log(format("Gravity turn launch complete. DV used {0:N0}m/s", (startDV - endDV)))
}

// Launch the vessel from a planet with an atmosphere into orbit
// - It doesn't trust maneuver nodes until it is in space
// - Less likely to overshoot apoapsis

pub fn launch_atmosphere(mission: Mission, target_apoapsis: float, 
                          turn_min: float, turn_max: float, heading: float) -> Unit = {

    const vessel = mission.vessel
    const con = mission.console.value

    // If we are landed or pre-launch, launch
    if (vessel.situation == VesselSituation.Landed || vessel.situation == VesselSituation.PreLaunch) {4
        con.log("Vessel is on the ground. Launch.")
        vessel.set_throttle(1)
        mission.stage()
        vessel.autopilot.mode = AutopilotMode.Autopilot
    }

    // calculate gravity turn altitudes
    const atm_depth = vessel.main_body.atmosphere_depth
    const turn_min_alt = atm_depth * turn_min
    const turn_max_alt = atm_depth * turn_max
    const initial_alt = max(target_apoapsis*0.9,atm_depth*1.05)

    con.log(format("Target Apoapsis {0:N}, heading {1:N} deg.", (target_apoapsis, heading)))
    con.h4 = format("Gravity turn starting at {0:N}m", turn_min_alt)

    // Phase one: burn until trajectory is 90% of apoapsis
    while(vessel.orbit.apoapsis.value < initial_alt) {

        // Check if high enough for gravity turn
        if (vessel.altitude_sealevel > turn_min_alt) {
            let pitch = acos_deg(clamp((vessel.altitude_sealevel - turn_min_alt) / (turn_max_alt-turn_min_alt), 0, 1))
            vessel.autopilot.target_orientation = vessel.heading_direction(heading, pitch, 0).vector
            con.h4 = format("Launch: {0:P1}  pitch: {1:N1} deg", (vessel.altitude_sealevel/target_apoapsis, pitch))
        }

        if (vessel.orbit.apoapsis.value/initial_alt > 0.95) {
            vessel.set_throttle( clamp(50*(1-(vessel.orbit.apoapsis.value/initial_alt)),0.1,1) )
        }

        // Check if we need to stage
        if( mission.flameout() ) {
            con.log("Flameout, advancing to new stage.")
            sleep(1)
            mission.stage()       
        }
        con.update_slow()
        sleep(0.1)
    }

    vessel.set_throttle(0)
    vessel.autopilot.mode = AutopilotMode.Prograde

    // If a solid state booster is still burning, wait for it to finish and stage
    check_and_finish_ssb(mission)

    let t_apo = vessel.orbit.next_apoapsis_time().value
    con.log(format("Apoapsis {0:N} in {1:N} seconds.", (vessel.orbit.apoapsis.value, t_apo-current_time())))

    // Critical: need to let the system catch up, otherwise maneuver node is broken
    sleep(1)

    // Split into two parts, first burn to 95% of dv at a max 98% or tatget apoapsis
    let n = circularize_at_ap(vessel)
    let n1 = Node(n.time-20,n.delta_v*0.95)
    mission.addManeuver(n1)
    const ap_step = max( max(atm_depth*1.05,target_apoapsis*0.98), vessel.orbit.apoapsis.value)
    mission.burnNextNodeAtm(ap_step)
    con.log("1st burn complete.")

    // Second, precision burn to raise periapsis
    let n2 = change_pe_at_ap(vessel,target_apoapsis)
    mission.addManeuver(n2)
    mission.burnNextNode()
    con.log("2nd burn complete.")

    if (vessel.orbit.periapsis < target_apoapsis) {
        con.log("Periapsis low, raising.")
        let n3 = circularize_at_ap(vessel)
        mission.addManeuver(n3)
        mission.burnNextNode()
    }

    con.log("Atmospheric launch complete.")
}

// Land on a body with atmosphere 
// - assumes we have a parachute, won't use engines for braking
// - will not stage to a second burn stage (for now)
// - assumes low-ish orbit (will lower & circularize if necessary)
// - completely ignored latitude, assumes everything is on the equator

pub fn land_atmosphere(mission: Mission, landing_site_maybe : Option<GeoCoordinates>) -> Unit = {

    const deorbit_angle = 87 // This is how much earlier we deorbit before the landing site. Should be simulated.

    const vessel = mission.vessel
    const con = mission.console.value

    const body = vessel.main_body
    const atm_depth = body.atmosphere_depth
    const frame = vessel.main_body.celestial_frame

    con.log("Initiating atmospheric landing.")

    if (!vessel.orbit.apoapsis.defined) {
        panic("land_atmosphere called without apoapsis, aborting.")
        return
    }

    // Check parachutes
    let chutes = 0
    let last_chute = 0
    con.log("  checking parachutes")
    for (i in 0..vessel.parts.length) {
        let p = vessel.parts[i]
        if (p.is_parachute) {
            con.log(format("    {0}",(p.part_name)))
            last_chute = i
            chutes += 1
        }
    }

    if (chutes == 0) {
        panic("No parachute found!")
        return
    }
    const test_chute = vessel.parts[last_chute].parachute.value

    // Periapsis outside of atmosphere. Plan a controlled landing.
    if ( vessel.orbit.periapsis > body.atmosphere_depth ) {

        if ( vessel.orbit.periapsis > body.atmosphere_depth*1.1 ) {
            // Lower orbit to atmosphere +5% if possible
            const alt_target = min(vessel.orbit.periapsis,atm_depth*1.05)
            con.log(format("  lowering to circular orbit at {0:N0} m",(alt_target)))
            mission.addManeuver(change_pe_at_ap( vessel,alt_target ))
            mission.burnNextNode()
            mission.addManeuver(circularize_at_pe(vessel))
            mission.burnNextNode()
        }

        let landing_site = body.geo_coordinates ( 0,0 )

        // Figure out where we need to deorbit
        if (landing_site_maybe.defined) {
            landing_site = landing_site_maybe.value
        } else {
            // Find the latitude with the sun overhead
            const lon_sun = lon_sunny_side(mission)
            const long = lat_nice_spot(mission)
            const lat = 0
            landing_site = body.geo_coordinates( lat,long )
            con.log(format("  landing site: {0:N1}/{1:N1}  (ship: {2:N1})",
                                (lat, long, vessel.geo_coordinates.longitude)) )
            //let sunny_marker = DEBUG.add_ground_marker(body.geo_coordinates ( 0,lon_sun ), YELLOW, 0)
        }
        let ground = DEBUG.add_ground_marker(landing_site, RED, 0)
        let origin = DEBUG.add_ground_marker(body.geo_coordinates( 0,0 ), BLUE, 0)

        // Location picked, let's land there.
        const rel_angle = (landing_site.longitude - vessel.geo_coordinates.longitude - deorbit_angle + 720) % 360

        // Correct for rotation
        let rot_corr = 1+vessel.orbit.period/body.rotation_period 
        const dt = rel_angle/360*vessel.orbit.period*rot_corr
        con.log(format("  rel angle to deorbit: {0:N} eta {1}",(rel_angle,dt)))

        // Determine dV needed to reduce periapsis to zero
        let n = change_pe_at_ap(vessel, 0)

        // Burn this amount of dV, but right time and direction
        n.time = current_time()+dt
        n.delta_v = -vessel.orbit.global_velocity(n.time).to_local(frame).normalized*n.delta_v.magnitude
        mission.addManeuver(n)
        mission.burnNextNode()
        
    } else {
        con.log(format("  periapsis at {0:N0} m below atmosphere {1:N0} m",(vessel.orbit.periapsis, atm_depth)))
    }

    // Periapsis inside of the athmosphere. We land.

    // Detach the last rocket stage, next are parachutes
    mission.stage()
    vessel.autopilot.mode = AutopilotMode.Retrograde

    warp_to(current_time()+3600)
    con.log("  waiting for altitude.")
    wait_until(fn() -> vessel.altitude_terrain < 5000)
    con.log("  waiting for parachute to be safe.")
    wait_until(fn() -> test_chute.chute_safety == ParachuteSafeStates.SAFE)
    ksp::game::warp::cancel()
    sleep(1)
    con.log("  parachute is safe. Deploying")
    mission.stage()   
    while( !mission.landed() ) con.update1()
    con.log(format("Welcome to {0}, alt {1:N0}",(body.name,vessel.altitude_terrain)))
}

// Aerocapture for the body we're orbiting
// Return once our apoapsis is inside athmosphere or periapsis is zero

pub fn aero_capture(mission: Mission) -> Unit = {

    const vessel = mission.vessel
    const con = mission.console.value
    const body = vessel.main_body
    const atm_depth = body.atmosphere_depth

    let capture_alt = atm_depth*0.8

    if (body.name == "Kerbin") {
        capture_alt = 48000.0
    }

    con.log(format("Initiating aerocapture at {0}",(body.name)))

    mission.burnManeuver(change_pe_at_ap(vessel, capture_alt))

    let n = 1
    while (vessel.orbit.apoapsis.value > atm_depth) {
        con.log(format("  orbit {0} -> PE: {1} AP: {2}",(n,pretty_distance(vessel.orbit.periapsis),pretty_distance(vessel.orbit.apoapsis.value))))
        n += 1

        const t_pe = vessel.orbit.next_periapsis_time(current_time())
        warp_to(t_pe)
        while(vessel.altitude_sealevel > atm_depth) sleep(1) 
        vessel.autopilot.mode = AutopilotMode.Retrograde

        // Time to exit athmosphere should be roughly 2x time to PE
        const dt_pe = vessel.orbit.next_periapsis_time(current_time())-current_time()
        warp_to(current_time()+dt_pe*2)

        // In the athmosphere. Wait for altitude to be outside of it.
        while(vessel.altitude_sealevel < atm_depth) {
            con.h4 = format("Waiting for Aerocapture.  PE: {0}  AP: {1} ({2:P0})", 
                             (pretty_distance(vessel.orbit.periapsis), pretty_distance(vessel.orbit.apoapsis.value), vessel.orbit.apoapsis.value/atm_depth))
            con.update1()

            if (vessel.orbit.periapsis < 0) {
                con.log("  periapsis is zero.")
                ksp::game::warp::cancel()
                return
            }

            if (vessel.orbit.apoapsis.value < atm_depth) {
                con.log("  apoapsis is inside atmosphere.")
                ksp::game::warp::cancel()
                return
            }
        }

    }

}